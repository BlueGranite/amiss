---
title: "Preprocess data"
output: html_notebook
---

## Setup

```{r}
library(magrittr)

source("../R/preprocessing.R")

training_set <- read.csv("../training_data.csv", as.is = TRUE)
test_set <- read.csv("../test_data.csv", as.is = TRUE)

source("../R/feature_definitions.R")
```

## Name data rows by strings identifying variants
```{r}
form_variant_ids <- function(data) {

  id_cols <- c("X.Chrom", "Pos", "Ref", "Alt", "FeatureID")

  apply(
    data[, id_cols],
    MARGIN = 1,
    function(x) paste0(x, collapse = ":")
  )

}
rownames(training_set) <- form_variant_ids(training_set)
rownames(test_set) <- form_variant_ids(test_set)
```

## Process variables

The response variable (i.e. outcome variable) is processed into 0 (negative) or 1 (positive).
```{r}
positive_classes <- c("Likely_pathogenic", "Pathogenic", "Pathogenic,_drug_response", "Pathogenic/Likely_pathogenic,_drug_response")
negative_classes <- c("Benign", "Likely_benign", "Uncertain_significance")

training_outcome <- compute_numeric_labels(training_set$CLNSIG, positive_classes, negative_classes)
names(training_outcome) <- row.names(training_set)
table(training_outcome)

test_outcome <- compute_numeric_labels(test_set$CLNSIG, positive_classes, negative_classes)
names(test_outcome) <- row.names(test_set)
table(test_outcome)
```

Categorical variables are processed into sets of dummy variables. Note that here each category is represented by a dummy variable. An extra category could be represented using these variables by leaving each value for an observation as `0`; this is one strategy for handling missing values in categorical variables. However, missing values are left as missing values at this point so that predictive mean matching can be also experimented on.

```{r}
training_dummy_categoricals <- dummify_categoricals(training_set[, categorical_features, drop = FALSE])
head(training_dummy_categoricals)

test_dummy_categoricals <- dummify_categoricals(test_set[, categorical_features, drop = FALSE])
```

If some dummy variables are present on the test set but not on the training set, the classifier cannot learn to use them and thus should just be removed. If some dummy variables are present on the training set but not on the test set, the classifier may still benefit from the additional training information, and a constant zero variable should be created on the test set to indicate lack of belonging to that class.

Since the latter scenario does not apply in our case, the implementation beyond checking for it is skipped.
```{r}
training_dummy_names <- training_dummy_categoricals %>% colnames
test_dummy_names <- test_dummy_categoricals %>% colnames

if (!setequal(training_dummy_names, test_dummy_names)) {

  not_in_test_set <- setdiff(training_dummy_names, test_dummy_names)
  not_in_training_set <- setdiff(test_dummy_names, training_dummy_names)

  if (length(not_in_test_set) > 0) {
    not_in_test_set %>% paste0(collapse = ", ") %>% paste0(" not in the test set") %>% print
  }

  if (length(not_in_training_set) > 0) {
     not_in_training_set %>% paste0(collapse = ", ") %>% paste0(" not in the training set; removing") %>% print
     test_dummy_categoricals[, not_in_training_set] <- NULL
  }
}
```

Next, the new dummy variables are bound to the `data.frame`. We keep also the original categorical variables, since they are easier to use for certain statistics computations.
```{r}
training_set <- cbind(
  training_set,
  training_dummy_categoricals
)

test_set <- cbind(
  test_set,
  test_dummy_categoricals
)
```

Finally, write out the processed data CSV file.
```{r}
write.csv(training_set, "../preprocessed_training_data.csv", row.names = TRUE)
write.csv(test_set, "../preprocessed_test_data.csv", row.names = TRUE)
write.csv(training_outcome, "../training_outcomes.csv", row.names = TRUE)
write.csv(test_outcome, "../test_outcomes.csv", row.names = TRUE)
```
